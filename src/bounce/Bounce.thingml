import "_Timer.thingml"

enumeration Color 
	@c_type "uint16_t"
	@c_byte_size "2"
{
	black 	@enum_val "0x0000"
	white	@enum_val "0xFFFF"
}

thing fragment Constants {
	// definition of the screen size (in pixels)
	readonly property XSIZE : UInt8 = 160 
	readonly property YSIZE : UInt8 = 128 
}


thing fragment BounceApp includes TimerMsgs, Constants, BouncingBallMsgs {
	
	abstract function initDisplay() @abstract "true"
	abstract function clearScreen() @abstract "true"
	abstract function setColor(c : Color) @abstract "true"
	abstract function drawRect(x : UInt8, y : UInt8, width : UInt8, height : UInt8) @abstract "true"
	abstract function fillRect(x : UInt8, y : UInt8, width : UInt8, height : UInt8) @abstract "true"
	abstract function drawText(x : UInt8, y : UInt8, size : UInt8, text : String) @abstract "true"
	
	required port clock {
		sends timer_start, timer_cancel
		receives timer_timeout
	}
	
	required port ball {
		sends bounce, stop
		receives updateBall
	}
	
	statechart SC init Welcome {
		
		on entry initDisplay()
		
		state Welcome {
			
			on entry do
				clearScreen()
				setColor(Color:white)
				fillRect(0,0,XSIZE, YSIZE)
				setColor(Color:black)
				fillRect(5,5,XSIZE-10, YSIZE-10)
				setColor(Color:white)
				drawText(30, YSIZE/2-10, 2, "Bounce !")
				clock!timer_start(0, 2000)
			end
			
			transition -> Bouncing event t : clock?timer_timeout guard t.id == 0
		}
		
		state Bouncing {
			
			on entry do 
				clearScreen()
				drawRect(0,0,XSIZE-1, YSIZE-1)
				ball!bounce()
				clock!timer_start(1, 30)
			end
			
			// Generate the clock for the animation
			internal event t:clock?timer_timeout guard t.id == 1 action clock!timer_start(1, 30)
			
			internal event e : ball?updateBall action do
				// clear the previous ball
				setColor(Color:black)
				fillRect(e.oldx-3, e.oldy-3, 6, 6)
				// Draw the new ball
				setColor(Color:white)
				fillRect(e.newx-2, e.newy-3, 4, 6)
				fillRect(e.newx-3, e.newy-2, 6, 4)
				
			end
					
		}
	}
}

thing fragment BouncingBallMsgs {
	message bounce()
	message stop()
	message updateBall(oldx : UInt8, oldy : UInt8, newx : UInt8, newy : UInt8)
}

thing fragment BouncingBall includes TimerMsgs, Constants, BouncingBallMsgs {
	
	required port clock {
		receives timer_timeout
	}

	provided port ball {
		receives bounce, stop
		sends updateBall
	}
	
	readonly property MAX : Int16 = 10000
	
	property bx : Int16 = MAX/2
	property by : Int16 = MAX/2
	// The speed of the ball is within 
	property dx : Int16 = 200
	property dy : Int16 = 130

	function getBallX(bx : UInt16) : UInt8 do
		var l : Long = bx 
		l = l * (XSIZE-8)
		l = l / (MAX+1) + 4
		return l as UInt8
	end
	
	function getBallY(by : UInt16) : UInt8 do
		var l : Long = by 
		l = l * (YSIZE-8)
		l = l / (MAX+1) + 4
		return l as UInt8
	end
	
	statechart SC init STOP {
		
		state STOP {
			
			transition -> BOUNCE event ball?bounce
		}
		
		state BOUNCE {
			
			property lastX : UInt8 = 200
			property lastY : UInt8 = 200
				
			internal event t : clock?timer_timeout guard t.id == 1 action do
				// Calculate the position of the new ball
				bx = bx + dx
				by = by + dy
				
				// Check for collisions
				if (bx < 0) 		do	dx = -dx 	bx = -bx			end
				else if (bx > MAX)	do	dx = -dx	bx = bx - (bx-MAX)	end
				if (by < 0)			do	dy = -dy	by = -by			end
				else if (by > MAX)	do	dy = -dy	by = by - (by-MAX)	end
				
				// Calculate the position on the screen
				var newX : UInt8 = getBallX(bx)
				var newY : UInt8 = getBallY(by)
				
				ball!updateBall(lastX, lastY, newX, newY)
				
				lastX = newX
				lastY = newY
			end
			
			transition -> STOP event ball?stop
					
		}
	}
}